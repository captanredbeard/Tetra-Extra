//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//
/*
package mod.captanredbeard.tetra_extra.effect.treeHarvest;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.function.BiConsumer;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import net.minecraft.block.BambooBlock;
import net.minecraft.block.Block;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.block.CactusBlock;
import net.minecraft.block.ChorusFlowerBlock;
import net.minecraft.block.ChorusPlantBlock;
import net.minecraft.block.KelpBlock;
import net.minecraft.block.KelpTopBlock;
import net.minecraft.block.LeavesBlock;
import net.minecraft.block.SugarCaneBlock;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.item.ItemStack;
import net.minecraft.tags.BlockTags;
import net.minecraft.util.Direction;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.IBlockReader;
import net.minecraft.world.World;

public class ChoppingBreak {
    public static final ChoppingBreak.Tree NO_TREE = new ChoppingBreak.Tree(Collections.emptyList(), Collections.emptyList());

    public ChoppingBreak() {
    }

    public static boolean canDynamicTreeCutFrom(Block startBlock) {
        return false;
    }

    @Nonnull
    public static Optional<AbstractBlockBreakQueue> findDynamicTree(Block startBlock, BlockPos pos) {
        return Optional.empty();
    }

    @Nonnull
    public static ChoppingBreak.Tree findTree(@Nullable IBlockReader reader, BlockPos pos) {
        if (reader == null) {
            return NO_TREE;
        } else {
            List<BlockPos> logs = new ArrayList();
            List<BlockPos> leaves = new ArrayList();
            Set<BlockPos> visited = new HashSet();
            List<BlockPos> frontier = new LinkedList();
            BlockState stateAbove = reader.getBlockState(pos.up());
            if (isVerticalPlant(stateAbove)) {
                logs.add(pos.up());

                for(int i = 1; i < 256; ++i) {
                    BlockPos current = pos.up(i);
                    if (!isVerticalPlant(reader.getBlockState(current))) {
                        break;
                    }

                    logs.add(current);
                }

                Collections.reverse(logs);
                return new ChoppingBreak.Tree(logs, leaves);
            } else {
                BlockPos currentPos;
                if (isChorus(stateAbove)) {
                    frontier.add(pos.up());

                    while(!frontier.isEmpty()) {
                        currentPos = (BlockPos)frontier.remove(0);
                        visited.add(currentPos);
                        logs.add(currentPos);
                        Direction[] var22 = Directions.directions;
                        int var24 = var22.length;

                        for(int var25 = 0; var25 < var24; ++var25) {
                            Direction direction = var22[var25];
                            BlockPos offset = currentPos.offset(direction);
                            if (!visited.contains(offset) && isChorus(reader.getBlockState(offset))) {
                                frontier.add(offset);
                            }
                        }
                    }

                    Collections.reverse(logs);
                    return new ChoppingBreak.Tree(logs, leaves);
                } else if (!validateCut(reader, pos)) {
                    return NO_TREE;
                } else {
                    visited.add(pos);
                    BlockPos.getAllInBox(pos.add(-1, 0, -1), pos.add(1, 1, 1)).forEach((p) -> {
                        frontier.add(new BlockPos(p));
                    });

                    while(!frontier.isEmpty()) {
                        currentPos = (BlockPos)frontier.remove(0);
                        if (!visited.contains(currentPos)) {
                            visited.add(currentPos);
                            if (isLog(reader.getBlockState(currentPos))) {
                                logs.add(currentPos);
                                addNeighbours(currentPos, frontier, visited);
                            }
                        }
                    }

                    visited.clear();
                    visited.addAll(logs);
                    frontier.addAll(logs);

                    while(true) {
                        BlockState blockState;
                        boolean isLog;
                        boolean isLeaf;
                        boolean isGenericLeaf;
                        do {
                            do {
                                if (frontier.isEmpty()) {
                                    return new ChoppingBreak.Tree(logs, leaves);
                                }

                                currentPos = (BlockPos)frontier.remove(0);
                            } while(!logs.contains(currentPos) && visited.contains(currentPos));

                            visited.add(currentPos);
                            blockState = reader.getBlockState(currentPos);
                            isLog = isLog(blockState);
                            isLeaf = isLeaf(blockState);
                            isGenericLeaf = isLeaf || isNonDecayingLeaf(blockState);
                        } while(!isLog && !isGenericLeaf);

                        if (isGenericLeaf) {
                            leaves.add(currentPos);
                        }

                        int distance = !isLeaf ? 0 : (Integer)blockState.get(LeavesBlock.DISTANCE);
                        Direction[] var13 = Directions.directions;
                        int var14 = var13.length;

                        for(int var15 = 0; var15 < var14; ++var15) {
                            Direction direction = var13[var15];
                            BlockPos offset = currentPos.offset(direction);
                            if (!visited.contains(offset)) {
                                BlockState state = reader.getBlockState(offset);
                                BlockPos subtract = offset.subtract(pos);
                                int horizontalDistance = Math.max(Math.abs(subtract.getX()), Math.abs(subtract.getZ()));
                                if (isLeaf(state) && (Integer)state.get(LeavesBlock.DISTANCE) > distance || isNonDecayingLeaf(state) && horizontalDistance < 4) {
                                    frontier.add(offset);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    public static boolean isChorus(BlockState stateAbove) {
        return stateAbove.getBlock() instanceof ChorusPlantBlock || stateAbove.getBlock() instanceof ChorusFlowerBlock;
    }

    public static boolean isVerticalPlant(BlockState stateAbove) {
        Block block = stateAbove.getBlock();
        if (block instanceof BambooBlock) {
            return true;
        } else if (block instanceof CactusBlock) {
            return true;
        } else if (block instanceof SugarCaneBlock) {
            return true;
        } else {
            return block instanceof KelpBlock ? true : block instanceof KelpTopBlock;
        }
    }



       > visited = new HashSet();
        List<BlockPos> frontier = new LinkedList();
        frontier.add(pos);
        frontier.add(pos.up());
        int posY = pos.getY();

        while(true) {
            BlockPos currentPos;
            boolean lowerLayer;
            do {
                if (frontier.isEmpty()) {
                    return true;
                }

                currentPos = (BlockPos)frontier.remove(0);
                visited.add(currentPos);
                lowerLayer = currentPos.getY() == posY;
            } while(!isLog(reader.getBlockState(currentPos)));

            if (!lowerLayer && !pos.equals(currentPos.down()) && isLog(reader.getBlockState(currentPos.down()))) {
                return false;
            }

            Direction[] var7 = Directions.directions;
            int var8 = var7.length;

            for(int var9 = 0; var9 < var8; ++var9) {
                Direction direction = var7[var9];
                if (direction != Direction.DOWN && (direction != Direction.UP || lowerLayer)) {
                    BlockPos offset = currentPos.offset(direction);
                    if (!visited.contains(offset)) {
                        frontier.add(offset);
                    }
                }
            }
        }
    }

    private static void addNeighbours(BlockPos pos, List<BlockPos> frontier, Set<BlockPos> visited) {
        BlockPos.getAllInBox(pos.add(-1, -1, -1), pos.add(1, 1, 1))
                .filter(o -> visited.contains(o))
                .forEach(p -> frontier.add(new BlockPos(p)));
    }


    private static boolean isLog(BlockState state) {
        return state.isIn(BlockTags.LOGS);
    }

    private static boolean isNonDecayingLeaf(BlockState state) {
        return state.isIn(BlockTags.WART_BLOCKS) || state.getBlock() == Blocks.SHROOMLIGHT;
    }

    private static boolean isLeaf(BlockState state) {
        return state.hasProperty(LeavesBlock.DISTANCE);
    }

    public static class Tree extends AbstractBlockBreakQueue {
        private final List<BlockPos> logs;
        private final List<BlockPos> leaves;

        public Tree(List<BlockPos> logs, List<BlockPos> leaves) {
            this.logs = logs;
            this.leaves = leaves;
        }

        public void destroyBlocks(World world, ItemStack toDamage, @Nullable PlayerEntity playerEntity, BiConsumer<BlockPos, ItemStack> drop) {
            this.logs.forEach(this.makeCallbackFor(world, 0.5F, toDamage, playerEntity, drop));
            this.leaves.forEach(this.makeCallbackFor(world, 0.125F, toDamage, playerEntity, drop));
        }
    }
}
*/